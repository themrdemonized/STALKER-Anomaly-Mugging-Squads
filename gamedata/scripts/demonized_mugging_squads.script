
-- demonized Mugging Squads
-- Generated with AnomalyModCreator

-- ; Original description by billwa
-- ; Basically they yell a quote, surround you and a guy comes up to talk and you have 3 dialogue [ptions. Pay  mugging fee, get forced into kidnapping and the classic resist.
-- ; Obviously when if you start shooting them before you're they're able to open up their yappers, all bets are off and it's a normal gun fight
-- ; Monolith and sin will try kidnapping you always, no mugging. If you agree, it should bring you back to a base where all of your gear is removed until you convert and you have two options before you do, agree or fight, but lmao with no gear.
-- ; It is entirely random and happens anywhere on the map except interiors like labs or main

local id = 70000
local idOffset = 0
local gizmos = {
	sphereSquad = nil,
}
local debugMode = true
local gizmosInitialized = false
function initializeGizmos()
	if gizmosInitialized then return end
	gizmosInitialized = true

	gizmos.sphereSquad = debug_render.add_object(id + idOffset, DBG_ScriptObject.sphere):cast_dbg_sphere()
end
function reset(gizmosArr, force)
	if debugMode or force then
		if gizmosArr then
			for i = 1, #gizmosArr do
				local gizmo = gizmosArr[i]
				if gizmos[gizmo] then
					local v = gizmos[gizmo]
					if type(v) == "table" then
						for i = 1, #v do
							local p = v[i]
							p.visible = false
						end
					else
						v.visible = false
					end
				end
			end
		else
			for k, v in pairs(gizmos) do
				if type(v) == "table" then
					for i = 1, #v do
						local p = v[i]
						p.visible = false
					end
				else
					v.visible = false
				end
			end		
		end
	end
end
function toggleDebugMode()
	debugMode = not debugMode
	if debugMode then
		initializeGizmos()
	else
		reset(nil, true)
	end
end

-- MCM
function load_defaults()
	local t = {}
	local op = demonized_mugging_squads_mcm.op
	for i, v in ipairs(op.gr) do
		if v.def ~= nil then
			t[v.id] = v.def
		end
	end
	return t
end

settings = load_defaults()

function load_settings()
	settings = load_defaults()
	if ui_mcm then
		for k, v in pairs(settings) do
			settings[k] = ui_mcm.get("demonized_mugging_squads/" .. k)
		end
	end
	return settings
end

function roundVec(v, num)
	return vector():set(
		round_idp(v.x, num),
		round_idp(v.y, num),
		round_idp(v.z, num)
	)
end

activeSquads = {}	-- current active mugging squads
delay = 60*60*24 -- game seconds
delaySpawn = 60 -- real seconds
delayState = 10	-- real seconds
spawnDistance = 200^2	-- don't spawn mugging squads below this distance
safeSmartDistance = 40^2 -- don't spawn mugging squads if player is near safe smart

local lastSpawnTime	-- the last time a mugging squad has been spawned

local currentLevelSmarts = {}
local linkedLevelSmarts = {}

squadStages = {
	approach = 1,
	talk = 2,
	done = 3,
}

--====================================< Utilities >====================================--
function addToActiveSquads(squad)
	activeSquads[squad.id] = {
		name = squad:section_name(),
		stage = squadStages.approach
	}
end

function setSquadStage(squad, num)
	activeSquads[squad.id].stage = num
end

function invalidateSquad(squad)
	print_tip("squad %s is invalidated", squad.id)
	-- attack(false, false)
	activeSquads[squad.id] = nil
end

function setSquadAsEnemy(squad)
	print_tip("squad %s is enemy!", squad.id)
	if squad.force_set_goodwill then
		squad:force_set_goodwill(-5000, db.actor)
	end
	for k in squad:squad_members() do
		local obj = level.object_by_id(k.id)
		local se_obj = alife_object(k.id)
		if obj then
			obj:set_relation(game_object.enemy, db.actor)
			obj:force_set_goodwill(-5000, db.actor)
		end
		if se_obj then
			se_obj:force_set_goodwill(-5000, db.actor)
		end
	end
end

function getFactions()
	return demonized_mugging_squads_options.faction_list
end

function isFactionsEnemies(f1, f2)
	return not game_relations.is_factions_friends(f1, f2)
end

function getSafeLevels()
	return demonized_mugging_squads_options.safe_levels
end

function getSafeSmarts()
	return demonized_mugging_squads_options.safe_smarts
end

function getFactionSquads()
	local squads = {}
	for k, v in pairs(demonized_mugging_squads_options.faction_squads) do
		squads[k] = str_explode(v, ",")
	end
	return squads
end

function getDangerRanks()
	return demonized_mugging_squads_options.danger_ranks
end

function getDangerReputations()
	return demonized_mugging_squads_options.danger_reputations
end

function trySpawn()
	-- gather factions
	local enemy_factions = {}
	local factions = getFactions()
	for i, faction in ipairs(factions) do
		if settings.allowSameSquads or get_actor_true_community() ~= faction then
			if settings.allowFriendlySquads or isFactionsEnemies(get_actor_true_community(), faction) then
				enemy_factions[#enemy_factions + 1] = faction
			end
		end 
	end
	local picked_squad = enemy_factions[math.random(#enemy_factions)]

	-- gather smarts
	local spawn_smrts = {}
	for name, smart in pairs(currentLevelSmarts) do
		local dist = smart.position:distance_to_sqr(db.actor:position())
		if dist > spawnDistance then
			local smrt = SIMBOARD.smarts[smart.id]
			if smrt then
				local pass = true
				for k, v in pairs(smrt.squads) do
					local squad = alife_object(k)
					if squad and squad.current_target_id and squad.current_target_id == smart.id and not squad:get_script_target() then
						pass = false
						break
					end
				end
				if pass then
					-- print_tip("-demonized_mugging_squads.trySpawn / [%s] is a possible smart found, distance: %s", name, dist)
					spawn_smrts[#spawn_smrts+1] = name
				end
			end
		end
	end
	
	if #spawn_smrts > 0 then
		local squads = getFactionSquads()[picked_squad]
		local squad = squads[math.random(#squads)]
		local spawn_smrt = spawn_smrts[math.random(#spawn_smrts)]
		print_tip("-demonized_mugging_squads.trySpawn / [%s] has been spawned in [%s]", squad, spawn_smrt)
	
		-- Spawn squad and target the player
		local sq = SIMBOARD:create_squad(SIMBOARD.smarts_by_names[spawn_smrt], squad)
		sq.scripted_target = "actor"
		sq.rush_to_target = true
		
		addToActiveSquads(sq)
		lastSpawnTime = game.get_game_time()
	end
end

function attack(state, rush)
	for k, v in pairs(activeSquads) do
		local se = alife_object(k)
		if se and se:section_name() == v.name then
			se.scripted_target = state and v.stage == squadStages.approach and "actor"
			se.rush_to_target = rush == true and v.stage == squadStages.approach

			print_tip("-demonized_mugging_squads. - target: %s - rush: %s, dist %s",
				se.scripted_target,
				se.rush_to_target, 
				(function()
					local commander = se:commander_id() and level.object_by_id(se:commander_id())
					return commander and commander:position():distance_to(db.actor:position())
				end)()
			)
		end
	end
end

function updateTalk()
	if not load_var(db.actor, "force_all_talk", false) then
		print_tip("actor not talking, updateTalk stop")
		UnregisterScriptCallback("actor_on_update", updateTalk)
		return
	end
	if not db.actor:is_talking() then
		print_tip("actor stop talking, force_all_talk false and updateTalk stop")
		save_var(db.actor, "force_all_talk", false)
		UnregisterScriptCallback("actor_on_update", updateTalk)
		return
	end
end

function forceTalk(npc)
	if not npc:is_talking() then
		local meet = db.storage[npc:id()].meet
		if meet then
			local use = meet.meet_manager.use
			meet.meet_manager.use = "true"
		end

		npc:enable_talk()
		npc:set_start_dialog("muggingDialogGiveMeYourShit")
		RegisterScriptCallback("actor_on_update", updateTalk)
		save_var(db.actor, "force_all_talk", true)
	    db.actor:run_talk_dialog(npc, true)
	end
end

--====================================< Callbacks >====================================--
function spawnTimer()
	--printf("-mugging_squads.spawnTimer called")
	ResetTimeEvent("demonized_mugging_squads", "mugging_squad_spawn", delaySpawn)
	
	local num = 1

	-- -- check rank
	-- local rank = ranks.get_obj_rank_name(db.actor)
	-- if getDangerRanks()[rank] then 
	-- 	num = num + getDangerRanks()[rank]
	-- end
	
	-- -- check reputaion
	-- local reputaion = utils_obj.get_reputation_name(db.actor:character_reputation())
	-- if getDangerReputations()[reputaion] then 
	-- 	num = num + getDangerReputations()[reputaion]
	-- end
	
	-- -- ignore if rank or rep doesn't meet the requirements
	-- if (num == 0) then
	-- 	return false
	-- end
	
	-- read date
	local current_time = game.get_game_time()
	if not lastSpawnTime then
		lastSpawnTime = current_time
		return false
	end
	
	-- ignore if timer hasn't been reached yet
	if current_time:diffSec(lastSpawnTime) < delay then
		return false
	end
	
	-- try to spawn if there isn't enough mugging squads
	if size_table(activeSquads) < num then
		print_tip("-demonized_mugging_squads.spawnTimer, is valid to spawn")
		trySpawn()
	end
	
	return false
end

function isSquadCommanderVisible(squad)
	local obj = squad:commander_id() and level.object_by_id(squad:commander_id())
	if obj then
		local screenpos = game.world2ui(obj)
		if screenpos.x > 0 and screenpos.x < 1024 and screenpos.y > 0 and screenpos.y < 768 then
			if db.actor:see(obj) then
				return true
			end
		end
	end
	return false
end

function addMoreMembersToSquad(squad, num)
	-- get squad positions
	local commander = alife_object(squad:commander_id())
	local pos = commander.position
	local lvid = commander.m_level_vertex_id
	local gvid = commander.m_game_vertex_id

	-- get squad smart
	local squad_smart = squad.smart_id and SIMBOARD.smarts[squad.smart_id].smrt
	if not squad_smart then
		print_tip("-demonized_mugging_squads.addMoreMembersToSquad, cant add members to %s, no smart", squad:name())
		return
	end

	-- get npc to spawn section
	local random_spawn = ini_sys:r_string_ex(squad:section_name(), "npc_random")
	if not random_spawn then
		print_tip("-demonized_mugging_squads.addMoreMembersToSquad, cant add members to %s, no random_spawn", squad:name())
		return
	end
	random_spawn = parse_names(random_spawn)

	print_tip("-demonized_mugging_squads.addMoreMembersToSquad, add members to %s : %s", squad:name(), num)
	for i = 1, num do
		local random_sec = random_spawn[math.random(1, #random_spawn)]

		-- add and setup new npc
		local new_member_id = squad:add_squad_member(random_sec, pos, lvid, gvid)
		local se_obj = new_member_id and alife_object(new_member_id)
		if (se_obj) then
			squad_smart:register_npc(se_obj)
			SIMBOARD:setup_squad_and_group(se_obj)
		end
	end

	squad:update()
end

-- Simplified parsing of condition list
defaultUseCond = "{=is_wounded} false, {!is_squad_commander} false, {=actor_enemy} false, {=has_enemy} false, {=dist_to_actor_le(3)} true, false"
local function parseConditionTable(npc, conditions)
	for i, v in ipairs(conditions) do
		local functions = v[2]
		local val = v[1]
		if functions then
			for _, func in ipairs(functions) do
				local f = func[1]
				local args = func[3] or {}
				local requiredResult = func[2] == 3
				if xr_conditions[f] then
					local result = not not xr_conditions[f](db.actor, npc, args)
					local r = result == requiredResult
					-- print_tip("parsing condition %s(%s) for %s: result %s", f, table.concat(args, ", "), npc:name(), result)
					if r then
						-- print_tip("parsing condition %s(%s) for %s: result fullfiled %s", f, table.concat(args, ", "), npc:name(), val)
						return val
					end
				end
			end
		else
			-- print_tip("parsing condition nil for %s: result fullfiled %s", npc:name(), val)
			return val
		end
	end
	return false
end
function parseCondition(npc, condString)
	local conditions = xr_logic.parse_condlist(npc, nil, nil, condString)
	local result = parseConditionTable(npc, conditions)
	if result == "true" then
		result = true
	elseif result == "false" then
		result = false
	end
	return result
end

function stateTimer()
	ResetTimeEvent("demonized_mugging_squads", "mugging_squad_state", delayState)
	
	-- clean
	local currentActorStage
	for id, v in pairs(activeSquads) do
		local se = alife_object(id)
		if (not se) or (se:section_name() ~= v.name) then
			print_tip("-demonized_mugging_squads.stateTimer cleaning [%s] | section: %s - actual: %s", id, v.name, se and se:section_name())
			activeSquads[id] = nil
		else
			local squad = se

			-- If squad is one man -- fill them up to random 2-5
			if squad:npc_count() <= 1 and not isSquadCommanderVisible(squad) and v.stage == squadStages.approach then
				addMoreMembersToSquad(squad, math.random(4))
			end

			if v.stage == squadStages.talk then
				currentActorStage = squadStages.talk
			elseif v.stage == squadStages.done then
				if not (
					simulation_objects.is_on_the_same_level(alife():actor(), squad)
					and isSquadCommanderVisible(squad)
				) then
					SIMBOARD:remove_squad(squad)
					invalidateSquad(squad)
				end
			end
		end
	end

	if is_empty(activeSquads) then
		return false
	end

	-- Don't attack if actor is talking to mugging squad
	if currentActorStage == squadStages.talk then
		attack(false, false)
		return false
	end
	
	-- don't attack if actor is in a safe level
	if getSafeLevels()[level.name()] then
		attack(false, false)
		return false
	end
	
	-- don't attack if actor is in a safe smart
	local pos = db.actor:position()
	local se_actor = alife():actor()
	local safeSmarts = getSafeSmarts()
	for name, smart in pairs(currentLevelSmarts) do
		if safeSmarts[name] then
			local dist = smart.position:distance_to_sqr(pos)
			if dist < safeSmartDistance then
				attack(false, false)
				return false
			end
		end
	end
	
	print_tip("player is vulnerable to mugging, attack")
	attack(true, true)
	
	return false
end

function load_state(m_data)
	local demonized_mugging_squads = m_data.demonized_mugging_squads
	if not demonized_mugging_squads then
		return
	end
	
	if DEV_DEBUG and demonized_mugging_squads then
		for k,v in pairs(demonized_mugging_squads) do
			print_tip("# LOADING: Mugging Squad | [%s]: %s", k, v)
		end
	end
	
	lastSpawnTime = demonized_mugging_squads.last_spawn_time and utils_data.CTime_from_table(demonized_mugging_squads.last_spawn_time) or game.get_game_time()
	activeSquads = demonized_mugging_squads.active_squads or {}
	for k, v in pairs(activeSquads) do
		if type(v) ~= "table" then
			activeSquads[k] = {
				name = v,
				stage = 1
			}
		end
	end
end

function save_state(m_data)
	if not lastSpawnTime then
		return
	end
	
	local demonized_mugging_squads = {}
	demonized_mugging_squads.last_spawn_time = utils_data.CTime_to_table(lastSpawnTime)
	demonized_mugging_squads.active_squads = activeSquads or {}
	
	if DEV_DEBUG then
		for k,v in pairs(demonized_mugging_squads) do
			print_tip("# SAVING: Mugging Squad | [%s]: %s", k, v)
		end
	end
	
	m_data.demonized_mugging_squads = demonized_mugging_squads
end

function server_entity_on_unregister(se_obj, typ)
	activeSquads[se_obj.id] = nil
end

function actor_on_first_update()
	if debugMode then
		initializeGizmos()
	end
	for name, smart in pairs(SIMBOARD.smarts_by_names) do
		if smart and simulation_objects.is_on_the_same_level(alife():actor(), smart) then
			currentLevelSmarts[name] = smart
		end
		if smart and simulation_objects.is_on_the_linked_level(alife():actor(), smart) then
			linkedLevelSmarts[name] = smart
		end
	end
	CreateTimeEvent("demonized_mugging_squads", "mugging_squad_spawn", delaySpawn, spawnTimer)
	CreateTimeEvent("demonized_mugging_squads", "mugging_squad_state", delayState, stateTimer)
end

function squad_on_update(squad)
	local id = squad.id
	if not activeSquads[id] then return end
	
	local commander = squad:commander_id() and level.object_by_id(squad:commander_id())
	local requiredGoodwill = 0

	if commander then
		if debugMode then
			gizmos.sphereSquad.visible = true
			gizmos.sphereSquad.color = fcolor():set(1,0,0,1)
		    local scale_mat = matrix():identity():scale(0.1,0.1,0.1)
		    local pos_mat = matrix():translate(commander:position())
		    local mat = matrix():mul(pos_mat, scale_mat)
		    gizmos.sphereSquad.matrix = mat
		end
		requiredGoodwill = math.max(0, -relation_registry.community_relation(character_community(commander), character_community(db.actor)))
		-- print_tip("setting goodwill to %s", requiredGoodwill)
	end

	if squad.force_set_goodwill then
		squad:force_set_goodwill(requiredGoodwill, db.actor)
	end
	for k in squad:squad_members() do
		local obj = level.object_by_id(k.id)
		local se_obj = alife_object(k.id)
		if obj then
			obj:set_relation(game_object.neutral, db.actor)
			obj:force_set_goodwill(requiredGoodwill, db.actor)
		end
		if se_obj then
			se_obj:force_set_goodwill(requiredGoodwill, db.actor)
		end
	end

	if activeSquads[id].stage == squadStages.approach then
		local commander = squad:commander_id() and level.object_by_id(squad:commander_id())
		if commander then
			local condition = parseCondition(commander, defaultUseCond)
			if condition then
				print_tip("npc %s start to talk, pos %s, actor %s, distance %s",
					commander:id(),
					roundVec(commander:position()),
					roundVec(db.actor:position()),
					commander:position():distance_to_sqr(db.actor:position())
				)
				attack(false, false)
				setSquadStage(squad, squadStages.talk)
				forceTalk(commander)
			end
		end
	end
end

function on_enemy_eval(obj, enemy, flags)

end

function npc_on_before_hit(npc, shit, bone_id, flags)
	if shit.draftsman:id() ~= AC_ID then return end

	local squad = get_object_squad(npc)
	if not squad then return end
	if not activeSquads[squad.id] then return end

	invalidateSquad(squad)
	setSquadAsEnemy(squad)
end

function on_game_start()	
	RegisterScriptCallback("save_state", save_state)
	RegisterScriptCallback("load_state", load_state)
	RegisterScriptCallback("actor_on_first_update", actor_on_first_update)
	RegisterScriptCallback("server_entity_on_unregister", server_entity_on_unregister)

	RegisterScriptCallback("on_enemy_eval", on_enemy_eval)
	RegisterScriptCallback("squad_on_update", squad_on_update)
	RegisterScriptCallback("npc_on_before_hit", npc_on_before_hit)

	RegisterScriptCallback("actor_on_first_update", load_settings)
	RegisterScriptCallback("on_option_change", load_settings)
end

-- Dialogs
local gt = game.translate_string
local GetTalkingNpc = mob_trade.GetTalkingNpc or function()
	--log("~GetTalkingNpc:->:tData.oNpc:clsid() == clsid.script_trader")
	for k,v in pairs(db.storage) do
		local oNpc = v.object
		if oNpc ~= nil then
			if oNpc:is_talking() and oNpc:id() ~= AC_ID then
				return oNpc
			end
		end
	end
end

local function getNpcAndActor(a, b)
	local npc = a:id() == AC_ID and b or a
	local actor = a:id() == AC_ID and a or b
	return npc, actor
end

function dialogs.demonized_mugging_squads_prepare_dialog_info(a, b)
	-- local npc = GetTalkingNpc()
end

function dialogs.demonized_mugging_squads_text_give_me_stuff()
	local s = gt("mugging_give_me_stuff")
	return s or ""
end

function dialogs.demonized_mugging_squads_text_here_is_my_stuff()
	local s = gt("mugging_here_is_my_stuff")
	return s or ""
end

function dialogs.demonized_mugging_squads_give_my_stuff(a, b)
	local npc, actor = getNpcAndActor(a, b)
	dialogs.relocate_money(npc, db.actor:money(), "out")
end     

function dialogs.demonized_mugging_squads_text_thank_you_and_gtfo()
	local s = gt("mugging_thank_you_and_gtfo")
	return s or ""
end

function dialogs.demonized_mugging_squads_text_ok()
	local s = gt("mugging_ok")
	return s or ""
end

function dialogs.demonized_mugging_squads_break_dialog(a, b)
	dialogs.break_dialog(a, b)
	local npc, actor = getNpcAndActor(a, b)
	local squad = get_object_squad(npc)
	if squad then
		setSquadStage(squad, squadStages.done)
	end
end

function dialogs.demonized_mugging_squads_text_fuck_you_and_start_fight()
	local s = gt("mugging_fuck_you_and_start_fight")
	return s or ""
end

function dialogs.demonized_mugging_squads_fuck_you_and_start_fight(a, b)
	dialogs.break_dialog(a, b)
	local npc, actor = getNpcAndActor(a, b)
	local squad = get_object_squad(npc)
	invalidateSquad(squad)
	setSquadAsEnemy(squad)
end
