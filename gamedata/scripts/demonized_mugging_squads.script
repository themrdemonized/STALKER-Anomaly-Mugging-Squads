
-- demonized Mugging Squads
-- Generated with AnomalyModCreator

-- ; Original description by billwa
-- ; Basically they yell a quote, surround you and a guy comes up to talk and you have 3 dialogue [ptions. Pay  mugging fee, get forced into kidnapping and the classic resist.
-- ; Obviously when if you start shooting them before you're they're able to open up their yappers, all bets are off and it's a normal gun fight
-- ; Monolith and sin will try kidnapping you always, no mugging. If you agree, it should bring you back to a base where all of your gear is removed until you convert and you have two options before you do, agree or fight, but lmao with no gear.
-- ; It is entirely random and happens anywhere on the map except interiors like labs or main

-- MCM
function load_defaults()
	local t = {}
	local op = demonized_mugging_squads_mcm.op
	for i, v in ipairs(op.gr) do
		if v.def ~= nil then
			t[v.id] = v.def
		end
	end
	return t
end

settings = load_defaults()

function load_settings()
	settings = load_defaults()
	if ui_mcm then
		for k, v in pairs(settings) do
			settings[k] = ui_mcm.get("demonized_mugging_squads/" .. k)
		end
	end
	return settings
end

active_squads = {}	-- current active bounty squads
delay = 60*60*24 -- game seconds
delay_spawn = 60 --300 -- real seconds
delay_state = 10	-- real seconds
spawn_distance = 200^2	-- don't spawn bounty squads below this distance
safe_smart_distance = 40^2

local last_spawn_time		-- the last time an bounty squad has been spawned

factions = {} -- List of factions that can send bounty squads
factions_only_kidnap = {}
safe_levels = {} -- bounty squad will stop targeting the player if he's in one of those maps
safe_smarts = {} -- bounty squad will stop targeting the player if he's in one of those smarts
faction_squads = {} -- bounty squad section
danger_ranks = {}	-- player ranks and the number of possible bounty squad to spawn when a rank is met 
danger_reputations = {} -- player reputations and the number of possible bounty squad to spawn when a reputation is met 

local currentLevelSmarts = {}
local linkedLevelSmarts = {}

--====================================< Utilities >====================================--
function try_spawn()
	-- gather factions
	local enemy_factions = {}
	for i, faction in ipairs(factions) do
		if settings.allowSameSquads or db.actor:character_community() ~= faction then
			enemy_factions[#enemy_factions + 1] = faction
		end 
	end
	local picked_squad = enemy_factions[math.random(#enemy_factions)]

	-- gather smarts
	local spawn_smrts = {}
	for name, smart in pairs(currentLevelSmarts) do
		local dist = smart.position:distance_to_sqr(db.actor:position())
		if dist > spawn_distance then
			local smrt = SIMBOARD.smarts[smart.id]
			if smrt then
				local pass = true
				for k, v in pairs( smrt.squads ) do
					local squad = alife_object(k)
					if squad and squad.current_target_id and squad.current_target_id == smart.id and not squad:get_script_target() then
						pass = false
						break
					end
				end
				if pass then
					-- print_tip("-demonized_mugging_squads.try_spawn / [%s] is a possible smart found, distance: %s", name, dist)
					spawn_smrts[#spawn_smrts+1] = name
				end
			end
		end
	end
	
	if #spawn_smrts > 0 then
		local squads = faction_squads[picked_squad]
		local squad = squads[math.random(#squads)]
		local spawn_smrt = spawn_smrts[math.random(#spawn_smrts)]
		print_tip("-demonized_mugging_squads.try_spawn / [%s] has been spawned in [%s]", squad, spawn_smrt)
	
		-- Spawn squad and target the player
		local sq = SIMBOARD:create_squad(SIMBOARD.smarts_by_names[spawn_smrt], squad)
		sq.scripted_target = "actor"
		sq.rush_to_target = true
		
		active_squads[sq.id] = sq:section_name()
		last_spawn_time = game.get_game_time()
	end
end

function attack(state, rush)
	for k,v in pairs(active_squads) do
		local se = alife_object(k)
		if se and se:section_name() == v then
			se.scripted_target = state and "actor" or nil
			se.rush_to_target = rush == true

			print_tip("-demonized_mugging_squads. - target: %s - rush: %s, dist %s",
				se.scripted_target,
				se.rush_to_target, 
				(function()
					local commander = se:commander_id() and level.object_by_id(se:commander_id())
					return commander and commander:position():distance_to(db.actor:position())
				end)()
			)
		end
	end
end

function forceTalk(npc)
	if not npc:is_talking() then
		local meet = db.storage[npc:id()].meet
		if meet then
			local use = meet.meet_manager.use
			meet.meet_manager.use = "true"
		end

		npc:enable_talk()
		npc:set_start_dialog("hello_dialog")
	    db.actor:run_talk_dialog(npc, false)
	end
end

--====================================< Callbacks >====================================--
function spawn_timer()
	--printf("-bounty_squads.spawn_timer called")
	ResetTimeEvent("demonized_mugging_squads", "mugging_squad_spawn", delay_spawn)
	
	local num = 1

	-- -- check rank
	-- local rank = ranks.get_obj_rank_name(db.actor)
	-- if danger_ranks[rank] then 
	-- 	num = num + danger_ranks[rank]
	-- end
	
	-- -- check reputaion
	-- local reputaion = utils_obj.get_reputation_name(db.actor:character_reputation())
	-- if danger_reputations[reputaion] then 
	-- 	num = num + danger_reputations[reputaion]
	-- end
	
	-- -- ignore if rank or rep doesn't meet the requirements
	-- if (num == 0) then
	-- 	return false
	-- end
	
	-- read date
	local current_time = game.get_game_time()
	if (not last_spawn_time) then
		last_spawn_time = current_time
		return false
	end
	
	-- ignore if timer hasn't been reached yet
	if (current_time:diffSec(last_spawn_time) < delay) then
		return false
	end
	
	-- try to spawn if there isn't enough bounty squads
	if (size_table(active_squads) < num) then
		print_tip("-demonized_mugging_squads.spawn_timer, is valid to spawn")
		try_spawn()
	end
	
	return false
end

function state_timer()
	--printf("-bounty_squads.state_timer called")
	ResetTimeEvent("demonized_mugging_squads", "mugging_squad_state", delay_state)
	
	-- clean
	for id, section in pairs(active_squads) do
		local se = alife_object(id)
		if (not se) or (se:section_name() ~= section) then
			print_tip("-demonized_mugging_squads.state_timer cleaning [%s] | section: %s - actual: %s", id, section, se and se:section_name())
			active_squads[id] = nil
		end
	end

	if is_empty(active_squads) then
		return false
	end
	
	-- don't attack if actor is in a safe level
	if safe_levels[level.name()] then
		attack(false, false)
		return false
	end
	
	-- don't attack if actor is in a safe smart
	local pos = db.actor:position()
	local se_actor = alife():actor()
	for name, smart in pairs(currentLevelSmarts) do
		if safe_smarts[name] then
			local dist = smart.position:distance_to_sqr(pos)
			if dist < safe_smart_distance then
				attack(false, false)
				return false
			end
		end
	end
	
	print_tip("player is vulnerable to mugging, attack")
	attack(true, true)
	
	return false
end

function load_state(m_data)
	local demonized_mugging_squads = m_data.demonized_mugging_squads
	if not demonized_mugging_squads then
		return
	end
	
	if DEV_DEBUG and demonized_mugging_squads then
		for k,v in pairs(demonized_mugging_squads) do
			print_tip("# LOADING: Mugging Squad | [%s]: %s", k, v)
		end
	end
	
	last_spawn_time = demonized_mugging_squads.last_spawn_time and utils_data.CTime_from_table(demonized_mugging_squads.last_spawn_time) or game.get_game_time()
	active_squads = demonized_mugging_squads.active_squads or {}
end

function save_state(m_data)
	if not last_spawn_time then
		return
	end
	
	local demonized_mugging_squads = {}
	demonized_mugging_squads.last_spawn_time = utils_data.CTime_to_table(last_spawn_time)
	demonized_mugging_squads.active_squads = active_squads or {}
	
	if DEV_DEBUG then
		for k,v in pairs(demonized_mugging_squads) do
			print_tip("# SAVING: Mugging Squad | [%s]: %s", k, v)
		end
	end
	
	m_data.demonized_mugging_squads = demonized_mugging_squads
end

function server_entity_on_unregister(se_obj, typ)
	active_squads[se_obj.id] = nil
end

function actor_on_first_update()
	for name, smart in pairs(SIMBOARD.smarts_by_names) do
		if smart and simulation_objects.is_on_the_same_level(alife():actor(), smart) then
			currentLevelSmarts[name] = smart
		end
		if smart and simulation_objects.is_on_the_linked_level(alife():actor(), smart) then
			linkedLevelSmarts[name] = smart
		end
	end
	CreateTimeEvent("demonized_mugging_squads", "mugging_squad_spawn", delay_spawn, spawn_timer)
	CreateTimeEvent("demonized_mugging_squads", "mugging_squad_state", delay_state, state_timer)
end

function squad_on_update(squad)
	local id = squad.id
	if not active_squads[id] then return end

	if squad.force_set_goodwill then
		squad:force_set_goodwill(0, db.actor)
	end
	for k in squad:squad_members() do
		local obj = level.object_by_id(k.id)
		if obj then
			obj:force_set_goodwill(0, db.actor)
		end
	end

	local commander = squad:commander_id() and level.object_by_id(squad:commander_id())
	if commander and commander:position():distance_to_sqr(db.actor:position()) < 9 then
		print_tip("npc %s start to talk, pos %s, actor %s, distance %s", commander:id(), commander:position(), db.actor:position(), commander:position():distance_to_sqr(db.actor:position()))
		invalidate_squad(squad)
		forceTalk(commander)
	end
end

function on_enemy_eval(obj, enemy, flags)

end

function invalidate_squad(squad)
	print_tip("squad %s is invalidated", squad.id)
	attack(false, false)
	active_squads[squad.id] = nil
end

function set_squad_as_enemy(squad)
	print_tip("squad %s is enemy!", squad.id)
	if squad.force_set_goodwill then
		squad:force_set_goodwill(-2000, db.actor)
	end
	for k in squad:squad_members() do
		local obj = level.object_by_id(k.id)
		if obj then
			obj:force_set_goodwill(-2000, db.actor)
		end
	end
end

function npc_on_before_hit(npc, shit, bone_id, flags)
	if shit.draftsman:id() ~= AC_ID then return end

	local squad = get_object_squad(npc)
	if not squad then return end
	if not active_squads[squad.id] then return end

	invalidate_squad(squad)
	set_squad_as_enemy(squad)
end

function on_game_start()
	local ini_settings = ini_file("plugins\\demonized_mugging_squads.ltx")
	local n = 0
	
	n = ini_settings:line_count("faction_list")
	for i=0,n-1 do
		local result, id, value	= ini_settings:r_line_ex("faction_list",i,"","")
		if id then
			factions[#factions + 1] = id
		end
	end

	n = ini_settings:line_count("faction_only_kidnap_list")
	for i=0,n-1 do
		local result, id, value	= ini_settings:r_line_ex("faction_only_kidnap_list",i,"","")
		if id then
			factions_only_kidnap[id] = true
		end
	end
	
	n = ini_settings:line_count("safe_levels")
	for i=0,n-1 do
		local result, id, value	= ini_settings:r_line_ex("safe_levels",i,"","")
		if id then
			safe_levels[id] = true
		end
	end
	
	n = ini_settings:line_count("safe_smarts")
	for i=0,n-1 do
		local result, id, value	= ini_settings:r_line_ex("safe_smarts",i,"","")
		if id then
			safe_smarts[id] = true
		end
	end
	
	n = ini_settings:line_count("faction_squads")
	for i=0,n-1 do
		local result, id, value	= ini_settings:r_line_ex("faction_squads",i,"","")
		if id and value then
			local squads = str_explode(value, ",")
			if is_not_empty(squads) then
				faction_squads[id] = squads
			end
		end
	end
	
	n = ini_settings:line_count("danger_ranks")
	for i=0,n-1 do
		local result, id, value	= ini_settings:r_line_ex("danger_ranks",i,"","")
		if id and value then
			danger_ranks[id] = tonumber(value) or 0
		end
	end
	
	n = ini_settings:line_count("danger_reputations")
	for i=0,n-1 do
		local result, id, value	= ini_settings:r_line_ex("danger_reputations",i,"","")
		if id and value then
			danger_reputations[id] = tonumber(value) or 0
		end
	end
	
	RegisterScriptCallback("save_state", save_state)
	RegisterScriptCallback("load_state", load_state)
	RegisterScriptCallback("actor_on_first_update", actor_on_first_update)
	RegisterScriptCallback("server_entity_on_unregister", server_entity_on_unregister)

	RegisterScriptCallback("on_enemy_eval", on_enemy_eval)
	RegisterScriptCallback("squad_on_update", squad_on_update)
	RegisterScriptCallback("npc_on_before_hit", npc_on_before_hit)

	RegisterScriptCallback("actor_on_first_update", load_settings)
	RegisterScriptCallback("on_option_change", load_settings)
end
                        